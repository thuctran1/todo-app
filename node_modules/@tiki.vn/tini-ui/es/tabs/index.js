import { selectAsync, selectAllAsync } from '../_util/query';
import { getSystemInfoAsync } from '../_util/system';
Component({
  props: {
    className: '',
    activeCls: '',
    tabBarCls: '',
    tabContentCls: '',
    tabBarUnderlineColor: '',
    tabBarActiveTextColor: '',
    tabBarInactiveTextColor: '',
    tabBarSubTextColor: '',
    tabBarActiveSubTextColor: '',
    tabBarBackgroundColor: '',
    tabBarActiveIconColor: '#1A94FF',
    tabBarInactiveIconColor: '#808089',
    iconSize: 24,
    swipeable: true,
    activeTab: 0,
    animation: true,
    duration: 500,
    hasSubTitle: false,
    tabBarUnderlineWidth: '',
    tabBarUnderlineHeight: '',
    tabContentHeight: '',
    stickyBar: false
  },
  data: {
    windowWidth: 0,
    tabWidth: 0.25,
    autoplay: false,
    animation: false,
    viewScrollLeft: 0,
    boxWidth: 0,
    elWidth: 0,
    tabsWidthArr: []
  },
  didMount: function didMount() {
    var _this = this;

    var _this$props = this.props,
        tabs = _this$props.tabs,
        animation = _this$props.animation,
        activeTab = _this$props.activeTab,
        tabsName = _this$props.tabsName;
    getSystemInfoAsync().then(function (systemInfo) {
      var data = {
        windowWidth: systemInfo.windowWidth,
        elWidth: _this.data.elWidth,
        elLeft: _this.data.elLeft,
        tabWidth: _this.data.tabWidth,
        animation: _this.data.animation,
        autoplay: _this.data.autoplay,
        boxWidth: _this.data.boxWidth,
        viewScrollLeft: _this.data.viewScrollLeft
      };

      if (tabs && tabs.length > 0) {
        data.tabWidth = tabs.length > 3 ? 0.25 : 1 / tabs.length;
        data.animation = animation;
        data.autoplay = true;

        if (+activeTab > 0) {
          Promise.all([selectAsync("#tabs-item-" + tabsName + "-" + activeTab), selectAsync("#tu-tabs-bar-" + tabsName + "-content")]).then(function (rs) {
            var activeTabEle = rs[0],
                tabContentEle = rs[1];
            data.elWidth = activeTabEle.width;
            data.elLeft = activeTabEle.left;
            data.boxWidth = tabContentEle.width;
            data.viewScrollLeft = Math.floor(data.elWidth + data.elLeft - data.boxWidth);
            setTimeout(function () {
              _this.setData(data);
            }, 300);
          });
        }
      }
    });
  },
  didUpdate: function didUpdate(prevProps, prevData) {
    var _this2 = this;

    if (JSON.stringify(prevProps) === JSON.stringify(this.props) && JSON.stringify(prevData) === JSON.stringify(this.data)) {
      return;
    }

    var _this$props2 = this.props,
        currentActiveTab = _this$props2.activeTab,
        tabsName = _this$props2.tabsName,
        swipeable = _this$props2.swipeable,
        tabBarCls = _this$props2.tabBarCls;

    if (currentActiveTab !== prevProps.activeTab) {
      var className = "tu-tabs-bar-tab " + tabBarCls; // To prevent trigger multiple times setData, store value in data and update 1 time

      var data = {
        tabsWidthArr: this.data.tabsWidthArr,
        elWidth: this.data.elWidth,
        elLeft: this.data.elLeft,
        boxWidth: this.data.boxWidth,
        viewScrollLeft: this.data.viewScrollLeft
      };
      Promise.all([selectAllAsync("." + className), selectAsync("#tabs-item-" + tabsName + "-" + currentActiveTab)]).then(function (rs) {
        var allTabs = rs[0],
            currentTab = rs[1];
        data.tabsWidthArr = allTabs.map(function (item) {
          return item.width;
        });
        data.elWidth = currentTab.width;
        data.elLeft = currentTab.left;
        selectAsync("#tu-tabs-bar-" + tabsName + "-content").then(function (tabContent) {
          data.boxWidth = tabContent.width; // mock el.offsetLeft

          var elOffeseLeft = data.tabsWidthArr.reduce(function (prev, cur, index) {
            if (index < currentActiveTab) {
              prev += cur;
            }

            return prev;
          }, 0); // Update scrollLeft

          if (data.elWidth > data.boxWidth / 2) {
            data.viewScrollLeft = elOffeseLeft - 40;
          } else {
            data.viewScrollLeft = swipeable ? elOffeseLeft : elOffeseLeft - Math.floor(data.boxWidth / 2);
          }

          setTimeout(function () {
            _this2.setData(data);
          }, 300);
        });
      });
    }
  },
  methods: {
    handleTabClick: function handleTabClick(e) {
      var _e$target$dataset = e.target.dataset,
          index = _e$target$dataset.index,
          tabsName = _e$target$dataset.tabsName;

      if (this.props.onTabClick) {
        this.props.onTabClick({
          index: index,
          tabsName: tabsName
        });
      }
    },
    handleSwiperChange: function handleSwiperChange(e) {
      var current = e.detail.current;
      var tabsName = e.target.dataset.tabsName;

      if (this.props.onChange) {
        this.props.onChange({
          index: current,
          tabsName: tabsName
        });
      }
    }
  }
});